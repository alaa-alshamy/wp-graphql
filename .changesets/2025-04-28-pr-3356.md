---
title: "feat: lazy loading fields for Object Types and Interface Types"
pr: 3356
author: "jasonbahl"
type: "feat"
breaking: false
---

## What does this implement/fix? Explain your changes.

This PR introduces lazy evaluation of GraphQL field definitions through callable functions in the core type system. The key changes focus on:

1. Added support in \`WPInterfaceTrait\` to handle callable field definitions:
\`\`\`php
if ( is_callable( $config['fields'] ) ) {
    $config['fields'] = $config['fields']();
}
\`\`\`

2. Modified \`WPInterfaceType\` and \`WPObjectType\` to use callable functions for field definitions:
\`\`\`php
$config['fields'] = function () use ( $config ) {
    return ! empty( $this->fields ) ? $this->fields : $this->get_fields( $config, $this->type_registry );
};
\`\`\`

This architectural change defers the execution of field definitions until they are actually needed, rather than defining all fields upfront during schema initialization.

### Before/After Example

Here's an example of how the \`User\` type fields were refactored:

**Before:**
\`\`\`php
'fields' => [
    'id' => [
        'description' => __( 'The globally unique identifier for the user object.', 'wp-graphql' ),
    ],
    'name' => [
        'type' => 'String',
        'description' => __( 'Display name of the user.', 'wp-graphql' ),
    ],
    // ... more fields
]
\`\`\`

**After:**
\`\`\`php
'fields' => static function () {
    return [
        'id' => [
            'description' => __( 'The globally unique identifier for the user object.', 'wp-graphql' ),
        ],
        'name' => [
            'type' => 'String',
            'description' => __( 'Display name of the user.', 'wp-graphql' ),
        ],
        // ... more fields
    ];
}
\`\`\`

To measure the impact of this change, we added a \`TestGetText\` class that tracks all \`__()\` function calls during schema generation and query execution. This logging shows that translations are now only executed when fields are actually queried, rather than during schema initialization.

\`\`\`php
class TestGetText {

	/**
	 * @var array
	 */
	protected $gettext_log = [];

	/**
	 * Constructor
	 */
	public function __construct() {
		// Reset at the very start of schema generation
		add_action( 'graphql_process_http_request', [ $this, 'init_log' ], 1 );

		// Track all translations
		add_filter(
			'gettext',
			function ( $text ) {
				$this->gettext_log[] = $text;
				return $text;
			},
			10,
			3
		);

		// Add to extensions
		add_filter( 'graphql_request_results', [ $this, 'add_to_extensions' ], 10, 1 );
	}

	/**
	 * Initialize the log
	 */
	public function init_log(): void {
		$this->gettext_log = [];
	}

	/**
	 * Add translation data to GraphQL extensions
	 *
	 * @param \GraphQL\Executor\ExecutionResult $response The GraphQL response
	 */
	public function add_to_extensions( \GraphQL\Executor\ExecutionResult $response ): \GraphQL\Executor\ExecutionResult {
		$extensions                 = $response->extensions ?? [];
		$extensions['translations'] = [
			'count' => count( $this->gettext_log ),
			// 'log'   => $this->gettext_log,
		];
		$response->extensions       = $extensions;
		return $response;
	}
}

new TestGetText();
\`\`\`

## Does this close any currently open issues?

Working on #3354 (more to come)

## Any other comments?

This change provides significant performance benefits by:

1. **Deferred Translation**: The \`__()\` function calls for field descriptions are now only executed when the fields are actually used in a query, rather than during schema initialization. This is particularly important for multilingual sites where translation lookups can be expensive.

2. **Reduced Memory Usage**: Field definitions that are rarely used in queries no longer need to be stored in memory during the entire request lifecycle.

3. **Faster Schema Initialization**: The schema can be initialized more quickly since field definitions are not processed until they are actually needed.

4. **Better Resource Management**: Resources like database connections or complex calculations needed for field definitions are only allocated when the fields are actually queried.

The changes maintain full backward compatibility while providing these performance improvements. All existing functionality remains the same, but the implementation is now more efficient, especially for large WordPress installations with complex schemas.
